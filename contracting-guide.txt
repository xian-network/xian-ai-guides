XIAN NETWORK - SMART CONTRACT DEVELOPMENT GUIDE
===============================================

1. CORE LANGUAGE RULES
--------------------
LANGUAGE VERSION:
- Contracts must use Python 3.11 syntax. Features introduced in later versions are prohibited.

ALLOWED BUILTINS:
- Primitive types/constants: bool, int, str, float, dict, list, tuple, set, frozenset, True, False, None, Exception
- Type checks/conversions: isinstance, issubclass, bytes, bytearray, chr, ord, hex, bin, ascii, format, oct
- Math/iterables: abs, divmod, max, min, pow, round, sum, all, any, filter, map, range, reversed, sorted, zip
- Core utilities: len

EXPLICITLY FORBIDDEN:
- print() / file I/O
- Classes (class), async/await, lambda
- Exception handling (try/except/finally)
- Metaprogramming (eval, exec, getattr)
- Underscore prefixes/suffixes (__private_var, var__)
- Standard library imports (os, sys, json, etc.)

2. CONTRACT STRUCTURE
-------------------
MANDATORY TEMPLATE:
# State declarations (top-level only)
owner = Variable()
balances = Hash()

# Constructor (runs once on deployment)
@construct
def init():
    owner.set(ctx.caller)
    balances[ctx.caller] = 1000

# Exported function (public interface)
@export
def transfer(to: str, amount: int):
    assert amount > 0, "Amount must be positive"
    sender = ctx.caller
    balances[sender] -= amount
    balances[to] += amount

3. IMPORT SYSTEM RULES
--------------------
ALLOWED MODULE ACCESS:
- The runtime preloads `Variable`, `Hash`, `ForeignVariable`, `ForeignHash`, `LogEvent`, `ctx`, `Any`, `importlib`, `datetime`, `decimal`, `hashlib`, `crypto`, and `random` into the contract scope—use them directly.
- Do **not** add `import` statements for standard-library helpers; the linter rejects them. Nested imports (inside functions) are also blocked.
- For cross-contract calls use the injected `importlib` module: `token = importlib.import_module('currency')`.
- Target contract names must be lowercase, alphanumeric/underscore, and not start with `_`; `importlib.import_module` raises if the contract is missing or violates these rules.

FORBIDDEN IMPORTS:
- Any `from ... import ...` statement
- Standard library modules (os, sys, json, datetime, decimal, etc.)

4. TYPE SYSTEM & ANNOTATIONS
-------------------------
VALID PARAMETER TYPES (NO RETURN TYPES):
@export
def valid_annotations(
    name: str,                   # Primitive
    metadata: dict,              # Key-value store
    deadline: datetime.datetime, # datetime.datetime / datetime.timedelta allowed
    flag: bool,                  # Boolean flags are valid
    raw: Any                     # Use Any when dynamic typing is unavoidable
):                               # NO return type annotations allowed
    pass

FORBIDDEN:
- Return type annotations (-> str, -> int, -> None, etc.)
- Missing annotations on @export parameters (each argument must annotate)
- Contract addresses are strings prefixed with "con_" (e.g., "con_xsc001")

5. DECORATOR CONSTRAINTS
----------------------
STRICT RULES:
- Maximum ONE decorator per function
- Only ONE @construct function per contract
- Functions without decorators become private (auto-prefixed with __)

VALID DECORATORS:
@construct  # Constructor (only one allowed)
@export     # Public function

6. STATE MANAGEMENT
-----------------
ALLOWED ORM OBJECTS:
# Single-value storage
config = Variable(t=int, default_value=0)  # Optional type enforcement & default

# Key-value storage (max 16 dimensions)
ledger = Hash(default_value=0)

# Cross-contract access (read-only)
token_supply = ForeignVariable(
    foreign_contract='currency',
    foreign_name='total_supply'
)
# ForeignHash/ForeignVariable raise ReferenceError on writes; treat them as read-only views.

ORM CONSTRUCTION RULES:
# CORRECT
balances = Hash()
supply = Variable()

# FORBIDDEN 
balances = Hash(contract='token', name='bal')  # Auto-added by compiler
x, y = Hash(), Variable()                      # No tuple unpacking

HASH LIMITATIONS:
# FORBIDDEN - Cannot use 'in' operator with Hash
if pool_id in pools:  # ✗ Raises exception

# CORRECT - Check if value is None
pool = pools[pool_id]
if pool is not None:  # ✓ Proper existence check

# Hash returns default_value (None) for missing keys
user_balance = balances[user]  # Returns 0 if default_value=0, None otherwise
# Keys cannot contain ':' or '.', and slices (balances[:]) are rejected
# Floats stored in Hash are returned as ContractingDecimal instances automatically

7. CONTEXT VARIABLES & BLOCK INFO
-------------------------------
AVAILABLE CONTEXT:
@export
def get_context_info():
    sender = ctx.caller      # Who called this function
    signer = ctx.signer      # Transaction signer  
    contract = ctx.this      # Current contract name
    owner = ctx.owner        # Contract owner
    entry = ctx.entry        # (contract, function) dispatch tuple
    submission = ctx.submission_name  # Filled during submissions
    timestamp = now          # Current block timestamp
    height = block_num       # Current block number
    hash_val = block_hash    # Current block hash
    return {
        "caller": sender,
        "signer": signer,
        "contract": contract,
        "entry": entry,
        "submission": submission,
        "timestamp": timestamp,          # datetime.datetime instance
        "height": height,
        "hash": hash_val
    }

# `now`, `block_num`, `block_hash` (and optional salts) are injected by the execution environment; when testing with ContractingClient they default to deterministic values.

8. VARIABLE NAMING RESTRICTIONS
-----------------------------
FORBIDDEN NAMES:
- No function args can reuse ORM variable names
- No leading/trailing underscores (name_, _name, __name__)
- Reserved words: rt, Hash, Variable, LogEvent
- No ctx, now, block_num, block_hash as variable names

9. ALLOWED CONTROL FLOW
---------------------
PERMITTED PATTERNS:
# If-Elif-Else
if balances[ctx.caller] > 100:
    status = "VIP"
else:
    status = "Standard"

# For loops (bounded with range)
for i in range(10):
    process(i)

# Assertions (no exceptions!)
assert ctx.signer == owner.get(), "Unauthorized"

- Nested function definitions are rejected by the linter; define helpers at top level only.

10. CROSS-CONTRACT CALLS
---------------------
@export
def call_other_contract():
    # Absolute import only
    token = importlib.import_module('currency')
    
    # Interface validation
    required = [
        importlib.Func('transfer', args=('amount', 'to')),
        importlib.Var('balances', Hash)
    ]
    assert importlib.enforce_interface(token, required)
    
    # Execute call
    token.transfer(amount=100, to=ctx.caller)

11. AUTOMATIC TYPE CONVERSION
--------------------------
# Float literals auto-convert to ContractingDecimal
price = 10.5  # Becomes ContractingDecimal('10.5')

# Use decimal() constructor for operations
result = decimal('100.0') + decimal('50.25')

# Avoid float arithmetic issues
total = decimal(str(user_input))  # Convert safely

12. SYSTEM LIMITS
---------------
HASH DIMENSIONS: Maximum 16 levels
balances[user][token][pool]  # 3 dimensions ✓
data[a][b][c]...[p]         # 16 dimensions ✓  
data[a][b]...[q]            # 17 dimensions ✗

KEY SIZE: Maximum 1024 bytes per key
STAMP COSTS: Reads=1/byte, Writes=25/byte
RECURSION: Maximum 1024 levels

13. EVENT LOGGING
--------------
Events record significant contract state changes.

EVENT DEFINITION:
# Syntax
EventName = LogEvent(
    event="EventNameString",
    params={
        "param1": {"type": <valid_type>, "idx": <boolean>},
        "param2": {"type": <valid_type>, "idx": <boolean>},
    }
)

# Example
TransferEvent = LogEvent(
    event="Transfer",
    params={
        "from": {"type": str, "idx": True},   # idx=True enables filtering
        "to": {"type": str, "idx": True},
        "amount": {"type": (int, float, decimal)}
    }
)

EMITTING EVENTS:
@export
def transfer(amount: float, to: str):
    # ... transfer logic ...
    TransferEvent({"from": ctx.caller, "to": to, "amount": amount})

RULES:
- Use primitive types (str, int, float, bool) or tuples; include `decimal` when storing ContractingDecimal values
- idx=True marks parameters as indexable for queries
- **Maximum 3 indexed parameters (idx=True) per event**
- All defined parameters must be provided when emitting
- Each value must serialize to ≤1024 bytes; trim or hash larger payloads
- Convert non-primitives to str: str(now) for datetime

KEY VALIDATION CHECKLIST FOR LLMs
------------------------------
1. Use the injected deterministic `random` module and call `random.seed()` before generating values
2. No nested imports – use top-level importlib only
3. Contract must have at least one @export function
4. Variables must use Variable()/Hash(), not native types
5. No return type annotations (-> type) allowed
6. No underscore prefixes/suffixes in any names
7. No reuse of ORM names as function arguments
8. Max one decorator per function
9. Only one @construct function per contract
10. No tuple unpacking in ORM assignments
11. Float literals auto-convert to ContractingDecimal
12. Use ctx.caller, ctx.signer for transaction context
13. Access `datetime/decimal/hashlib/crypto/importlib/random` from injected globals; do not add standard-library import statements
14. Hash maximum 16 dimensions
15. All event parameters must match defined schema
16. **LogEvent maximum 3 indexed parameters (idx=True)**
17. **Cannot use 'in' operator with Hash - check if value is None instead**
18. Keep helper functions at module scope (nested defs are rejected)

OPTIMIZATION RULES
-----------------
# High cost: Write operations (25 stamps/byte)
balances[ctx.caller] = 500  # Minimize writes

# Low cost: Read operations (1 stamp/byte)  
balance = balances[ctx.caller]  # Reuse reads

# Batch operations when possible
user_balance = balances[ctx.caller]
user_balance += amount
balances[ctx.caller] = user_balance  # Single write

NUANCES
-------
# Random usage
random.seed()  # Call once per execution context before using randint(), choice(), etc.

# Datetime multiplication
5 * datetime.DAYS # does not work
>> TypeError: unsupported operand type(s) for *: 'int' and 'Timedelta'

datetime.DAYS * 5 # works

# Decimal argument
decimal(0.0) # does not work
>> TypeError: conversion from ContractingDecimal to Decimal is not supported

decimal("0.0") # works

# Division first before multiplication does not round up properly
amount_of_take_token_to_withdraw = (funder["amount_contributed"] / pool["amount_received"]) * pool["otc_actual_received_amount"] 
>> AssertionError: 149.99999999999999999999999999985 != 150

# Multiplication first before division
amount_of_take_token_to_withdraw = (funder["amount_contributed"] * pool["otc_actual_received_amount"]) / pool["amount_received"] # rounds up properly

# Pass keyword-argument to contract method
exploit_contract.setlisting(listing_id) # does not work
>> TypeError: AbstractContract._abstract_function_call() got multiple values for argument 'signer'

exploit_contract.setlisting(l=listing_id) # works


[END OF GUIDE]
